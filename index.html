<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Comprehensive VPN Leak & Network Diagnostics</title>
  <style>
    /* Clean, production‐style interface */
    body {
      font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f4f4f4;
      margin: 0;
      padding: 0;
    }
    header {
      background: #007acc;
      color: #fff;
      padding: 1em 0;
      text-align: center;
      font-size: 1.5em;
      font-weight: bold;
    }
    main {
      max-width: 900px;
      margin: 2em auto;
      padding: 1em;
    }
    section {
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 8px;
      margin-bottom: 1.5em;
      padding: 1em 1.5em;
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
    }
    section h2 {
      border-bottom: 1px solid #ddd;
      padding-bottom: 0.5em;
      margin-bottom: 1em;
      color: #007acc;
    }
    .result {
      font-size: 1em;
      line-height: 1.4em;
      word-wrap: break-word;
    }
    .result p {
      margin: 0.5em 0;
    }
    .ip { font-weight: bold; color: #007acc; }
    .error { color: red; }
    button {
      background: #007acc;
      border: none;
      color: #fff;
      padding: 0.7em 1.5em;
      font-size: 1.1em;
      border-radius: 5px;
      cursor: pointer;
      display: block;
      margin: 1em auto;
    }
    button:hover {
      background: #005fa3;
    }
  </style>
</head>
<body>
  <header>VPN Leak & Network Diagnostics</header>
  <main>
    <button id="startTest">Run All Tests</button>

    <section id="webrtcSection">
      <h2>WebRTC Leak Test</h2>
      <div id="webrtcResults" class="result"></div>
    </section>

    <section id="dnsSection">
      <h2>DNS Leak Test (Approximation)</h2>
      <div id="dnsResults" class="result"></div>
    </section>

    <section id="publicIPSection">
      <h2>Public IP & Proxy Check</h2>
      <div id="publicIPResults" class="result"></div>
    </section>

    <section id="stunSection">
      <h2>STUN Server Analysis</h2>
      <div id="stunResults" class="result"></div>
    </section>

    <section id="fingerprintSection">
      <h2>Browser Fingerprinting</h2>
      <div id="fingerprintResults" class="result"></div>
    </section>

    <section id="websocketSection">
      <h2>WebSocket Connection Test</h2>
      <div id="websocketResults" class="result"></div>
    </section>
  </main>

  <script>
    // Logging helper – writes messages to a given section.
    function log(id, message, isError = false) {
      const container = document.getElementById(id);
      const p = document.createElement('p');
      p.innerHTML = message;
      if (isError) {
        p.classList.add('error');
      }
      container.appendChild(p);
    }

    // Clears previous test results.
    function clearResults() {
      const sections = [
        'webrtcResults', 'dnsResults',
        'publicIPResults', 'stunResults',
        'fingerprintResults', 'websocketResults'
      ];
      sections.forEach(id => document.getElementById(id).innerHTML = '');
    }

    // Fully functional WebRTC Leak Test (IPv4 & IPv6)
    function detectWebRTCIps() {
      const RTCPeerConnection = window.RTCPeerConnection ||
                                window.mozRTCPeerConnection ||
                                window.webkitRTCPeerConnection;
      if (!RTCPeerConnection) {
        log("webrtcResults", "WebRTC is not supported by your browser.", true);
        return;
      }
      const ipSet = {};
      // Use multiple STUN servers for a more robust test.
      const config = { iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" }
      ]};
      const pc = new RTCPeerConnection(config);
      // Create a dummy channel.
      pc.createDataChannel("");

      pc.onicecandidate = (event) => {
        if (!event || !event.candidate) { pc.close(); return; }
        const candidate = event.candidate.candidate;
        // Regex to capture IPv4 and IPv6 addresses.
        const ipRegex = /((\d{1,3}(?:\.\d{1,3}){3})|(?:[a-fA-F0-9:]+:+[a-fA-F0-9]+))/g;
        let match;
        while ((match = ipRegex.exec(candidate)) !== null) {
          const ip = match[1];
          if (!ipSet[ip]) {
            ipSet[ip] = true;
            log("webrtcResults", "Detected IP: <span class='ip'>" + ip + "</span>");
          }
        }
      };
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .catch(error => log("webrtcResults", "Error during offer creation: " + error, true));
    }

    // DNS Leak Test (approximation): Loads resources from different domains.
    function testDNSLeak() {
      // In production, these domains should be under your control
      // so you can see where DNS requests originate.
      const testUrls = [
        "https://ipv4.icanhazip.com/",      // Returns plain IP
        "https://api.ipify.org/?format=json" // Returns JSON with public IP
      ];
      testUrls.forEach(url => {
        fetch(url, { cache: "no-cache" })
          .then(resp => resp.text())
          .then(data => {
            log("dnsResults", "Fetched from " + url + ": " + data.trim());
          })
          .catch(err => log("dnsResults", "Error fetching " + url + ": " + err, true));
      });
    }

    // Public IP & Proxy Check using ipify.
    function checkPublicIP() {
      fetch('https://api.ipify.org?format=json')
        .then(resp => resp.json())
        .then(data => {
          log("publicIPResults", "Your public IP: <span class='ip'>" + data.ip + "</span>");
        })
        .catch(err => log("publicIPResults", "Error fetching public IP: " + err, true));
    }

    // STUN Server Analysis: Logs candidate details per STUN server.
    function analyzeStunServers() {
      const RTCPeerConnection = window.RTCPeerConnection ||
                                window.mozRTCPeerConnection ||
                                window.webkitRTCPeerConnection;
      if (!RTCPeerConnection) {
        log("stunResults", "WebRTC is not supported by your browser.", true);
        return;
      }
      const config = { iceServers: [
        { urls: "stun:stun.l.google.com:19302" },
        { urls: "stun:stun1.l.google.com:19302" },
        { urls: "stun:stun.services.mozilla.com" }
      ]};
      const pc = new RTCPeerConnection(config);
      pc.createDataChannel("");
      const serverCandidates = {};

      pc.onicecandidate = (event) => {
        if (!event || !event.candidate) { pc.close(); return; }
        const candidate = event.candidate.candidate;
        // Extract the STUN server used from the candidate.
        const serverMatch = candidate.match(/stun:([^ ]+)/);
        const server = serverMatch ? serverMatch[1] : "unknown";
        serverCandidates[server] = serverCandidates[server] || [];
        serverCandidates[server].push(candidate);
        // Log only one representative candidate per server.
        if (serverCandidates[server].length === 1) {
          log("stunResults", "From STUN server <span class='ip'>" + server + "</span>: " + candidate);
        }
      };
      pc.createOffer()
        .then(offer => pc.setLocalDescription(offer))
        .catch(error => log("stunResults", "Error during STUN analysis: " + error, true));
    }

    // Browser Fingerprinting: Collect basic system information.
    function fingerprintBrowser() {
      const tz = Intl.DateTimeFormat().resolvedOptions().timeZone;
      const lang = navigator.language || navigator.userLanguage;
      const platform = navigator.platform;
      const agent = navigator.userAgent;
      log("fingerprintResults", "Time Zone: " + tz);
      log("fingerprintResults", "Language: " + lang);
      log("fingerprintResults", "Platform: " + platform);
      log("fingerprintResults", "User Agent: " + agent);
    }

    // WebSocket Connection Test: Connect to an external echo server.
    function testWebSocket() {
      const wsUrl = "wss://echo.websocket.events/";
      try {
        const ws = new WebSocket(wsUrl);
        ws.onopen = () => {
          log("websocketResults", "WebSocket connected to " + wsUrl);
          ws.send("Ping");
        };
        ws.onmessage = (evt) => {
          log("websocketResults", "WebSocket echo: " + evt.data);
          ws.close();
        };
        ws.onerror = (err) => log("websocketResults", "WebSocket error: " + err, true);
      } catch (e) {
        log("websocketResults", "WebSocket exception: " + e, true);
      }
    }

    // Main function: runs all tests.
    document.getElementById('startTest').addEventListener('click', () => {
      clearResults();
      detectWebRTCIps();
      testDNSLeak();
      checkPublicIP();
      analyzeStunServers();
      fingerprintBrowser();
      testWebSocket();
    });
  </script>
</body>
</html>
